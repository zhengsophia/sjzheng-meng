import React, { useState, useCallback, useEffect } from "react";
import ReactFlow, {
    MiniMap,
    Controls,
    addEdge,
    Connection,
    Edge,
    Node,
} from "reactflow";
import "reactflow/dist/style.css";
import MainNode from "./components/MainNode";
import SatelliteNode from "./components/SatelliteNode";
import Legend from "./components/Legend";
import extractVariablesFromCode from "./parser";
import dagre from "@dagrejs/dagre";
import OpenAI from "openai";
import twitter_sentiment from './data/twitter-sentiment-extaction-analysis-eda-and-model.json';
import bookings_cancellations from './data/eda-of-bookings-and-ml-to-predict-cancelations.json';
import lkin27js09bspace from './data/lkin27js09bspace.json';
import bjs827ee1uhappiness from './data/bjs827ee1uhappiness.json';
import fitbit_fitness_tracker_data from './data/fitbit_fitness_tracker_data.json';
import titanic_top_4_with_ensemble_modeling from './data/titanic_top_4_with_ensemble_modeling.json';

import { traceJson } from "./tracer";

interface NodeData {
    label: string;
}
interface PreliminaryNode {
    id: string;
    data: any;
}
interface PreliminaryEdges {
    source: string;
    target: string;
}

const nodeTypes = { MainNode: MainNode, SatelliteNode: SatelliteNode };

const Graph: React.FC = () => {
    // initialize graph with dummy data
    const [nodes, setNodes] = useState<Node<NodeData>[]>([]);
    const [edges, setEdges] = useState<Edge[]>([]);
    const [colorMap, setColorMap] = useState<Record<string, string>>({});

    // show notebook info in console -> ONLY FOR PROCESSING IPYNB FILE
    // useEffect(() => {
        // public folder method
        // const convertNotebookToJSON = async () => {
        //     try {
        //         const response = await fetch('/titanic-top-4-with-ensemble-modeling.ipynb');
        //         console.log('response', response);
        //         if (!response.ok) throw new Error('Error in network response');
        //         const notebook = await response.json();
        //         console.log('notebook json', notebook);
        //         const notebookCells = notebook.cells.filter((cell: { cell_type: string; }) => cell.cell_type === 'code');
        //         console.log(notebookCells);
        //     } catch (error) {
        //         console.error('Error fetching notebook:', error);
        //     }
        //     };
        // convertNotebookToJSON();
    // }, []);

    // handles edge creation
    const onConnect = useCallback(
        (params: Edge<any> | Connection) => {
            console.log("params:", params); 
            if (params.sourceHandle === 'bottom' && params.targetHandle === 'top') {
                // console.log('source', params.sourceHandle);
                // console.log('target', params.targetHandle);
                setEdges((eds) => addEdge({ ...params, animated: true }, eds));
            } else {
                console.log("edges can only be created from the bottom of the source to the top of the target!");
            }
        },
        []
    );

    const colorMapping: Record<any, any> = {
        "Environment Setup": "#0A1E1F",
        "Unlabeled": "#0F203D",
        "Data Import": "#24135E",
        "Data Overview": "#6E1381",
        "Data Cleaning": "#A61166",
        "Visualizations": "#CE100D",
        "Modeling Setup": "#F99C06",
        "Model Training": "#CFFF24",
        "Model Prediction": "#69FF47"
      };


      const narrativeVignette = `The user started their analysis by importing essential libraries, including pandas, numpy, and seaborn, to facilitate data manipulation and visualization. They quickly set up their environment by executing the necessary import statements and ensuring that warnings are suppressed to maintain a clean output during exploration. With the dataset pathways established, they proceeded to load the training and test datasets from a CSV file.
Upon loading the data, the user analyzed the shape of both the training and test datasets using 'print(train.shape)' and 'print(test.shape)' to understand the data's structure. They explored the training data further by invoking 'train.info()', which provided a comprehensive overview of the available columns and data types. Noticing a significant number of null values, the user made a pivotal decision to drop these missing rows via 'train.dropna(inplace=True)', ensuring that their subsequent analysis was based on complete records.
The user began to probe deeper into the sentiment distribution captured in the 'sentiment' column. They executed a group-by operation to count occurrences of each sentiment, visualizing this distribution through a count plot generated by seaborn. This step illuminated the relative frequency of sentiments in the dataset.
Next, they created a funnel chart using Plotly to illustrate the sentiment distribution visually. As they explored text relationships, the user implemented the Jaccard similarity measure within a loop to compute how similar the selected text is to the entire text for each entry in the training set. The results were compiled into a new DataFrame, facilitating further analysis of textual similarity.
Capitalizing on their findings, the user engineered additional features in the DataFrame, including counts of words in both selected text and main text, and the difference in word counts between these two fields. They visualized the distribution of this difference utilizing a combination of kernel density estimation and histograms to identify distinctive patterns across sentiments.
The notebook progressed with further insights into natural language processing; the user ran analysis to remove stop words and produced visualizations to represent the most common words found in positive, negative, and neutral sentiments. They generated multiple bar charts to represent these findings, emphasizing their understanding of common language use across different sentiments.
Engaging with advanced computation, the user prepared sentiment-specific training data for a named entity recognition (NER) model using spaCy. They iteratively trained the model on both positive and negative sentiment datasets, demonstrating a fluency with machine learning protocols. Through a systematic approach, they related the entities detected within individual texts back to the original messages, culminating in an enhanced model that could predict sentiments in unseen text data.
Finally, the user assembled the separate selected texts predicted for the test dataset, readying their output for submission after efficiently compiling results into a structured CSV format. The session concluded with the user examining their submission, reflecting the journey from data exploration to model training and prediction-driven insights.
    `;

    const narrativeMap = [
        { sentence: 0, cell_start: 1, cell_end: 1, label: 'Environment Setup' },
        { sentence: 1, cell_start: 2, cell_end: 2, label: 'Environment Setup' },
        { sentence: 2, cell_start: 3, cell_end: 3, label: 'Data Import' },
        { sentence: 3, cell_start: 4, cell_end: 4, label: 'Data Overview' },
        { sentence: 4, cell_start: 5, cell_end: 5, label: 'Data Overview' },
        { sentence: 5, cell_start: 6, cell_end: 6, label: 'Data Cleaning' },
        { sentence: 6, cell_start: 7, cell_end: 7, label: 'Data Cleaning' },
        { sentence: 7, cell_start: 8, cell_end: 8, label: 'Data Cleaning' },
        { sentence: 8, cell_start: 9, cell_end: 9, label: 'Data Cleaning' },
        { sentence: 9, cell_start: 10, cell_end: 10, label: 'Data Cleaning' },
        { sentence: 10, cell_start: 11, cell_end: 11, label: 'Visualizations' },
        { sentence: 11, cell_start: 12, cell_end: 12, label: 'Visualizations' },
        { sentence: 12, cell_start: 13, cell_end: 13, label: 'Visualizations' },
        { sentence: 13, cell_start: 14, cell_end: 14, label: 'Visualizations' },
        { sentence: 14, cell_start: 15, cell_end: 15, label: 'Visualizations' },
        { sentence: 15, cell_start: 16, cell_end: 16, label: 'Visualizations' },
        { sentence: 16, cell_start: 17, cell_end: 17, label: 'Visualizations' },
        { sentence: 17, cell_start: 18, cell_end: 18, label: 'Visualizations' },
        { sentence: 18, cell_start: 19, cell_end: 19, label: 'Visualizations' },
        { sentence: 19, cell_start: 20, cell_end: 20, label: 'Visualizations' },
        { sentence: 20, cell_start: 21, cell_end: 21, label: 'Visualizations' },
        { sentence: 21, cell_start: 22, cell_end: 22, label: 'Visualizations' },
        { sentence: 22, cell_start: 23, cell_end: 23, label: 'Visualizations' },
        { sentence: 23, cell_start: 24, cell_end: 24, label: 'Visualizations' },
        { sentence: 24, cell_start: 25, cell_end: 25, label: 'Visualizations' },
        { sentence: 25, cell_start: 26, cell_end: 26, label: 'Visualizations' },
        { sentence: 26, cell_start: 27, cell_end: 27, label: 'Visualizations' },
        { sentence: 27, cell_start: 28, cell_end: 28, label: 'Visualizations' },
        { sentence: 28, cell_start: 29, cell_end: 29, label: 'Visualizations' },
        { sentence: 29, cell_start: 30, cell_end: 30, label: 'Visualizations' },
        { sentence: 30, cell_start: 31, cell_end: 31, label: 'Visualizations' },
        { sentence: 31, cell_start: 32, cell_end: 32, label: 'Visualizations' },
        { sentence: 32, cell_start: 33, cell_end: 33, label: 'Visualizations' },
        { sentence: 33, cell_start: 34, cell_end: 34, label: 'Visualizations' },
        { sentence: 34, cell_start: 35, cell_end: 35, label: 'Visualizations' },
        { sentence: 35, cell_start: 36, cell_end: 36, label: 'Visualizations' },
        { sentence: 36, cell_start: 37, cell_end: 37, label: 'Visualizations' },
        { sentence: 37, cell_start: 38, cell_end: 38, label: 'Visualizations' },
        { sentence: 38, cell_start: 39, cell_end: 39, label: 'Visualizations' },
        { sentence: 39, cell_start: 40, cell_end: 40, label: 'Visualizations' },
        { sentence: 40, cell_start: 41, cell_end: 41, label: 'Visualizations' },
        { sentence: 41, cell_start: 42, cell_end: 42, label: 'Visualizations' },
        { sentence: 42, cell_start: 43, cell_end: 43, label: 'Visualizations' },
        { sentence: 43, cell_start: 44, cell_end: 44, label: 'Visualizations' },
        { sentence: 44, cell_start: 45, cell_end: 45, label: 'Visualizations' },
        { sentence: 45, cell_start: 46, cell_end: 46, label: 'Visualizations' },
        { sentence: 46, cell_start: 47, cell_end: 47, label: 'Visualizations' },
        { sentence: 47, cell_start: 48, cell_end: 48, label: 'Visualizations' },
        { sentence: 48, cell_start: 49, cell_end: 49, label: 'Visualizations' },
        { sentence: 49, cell_start: 50, cell_end: 50, label: 'Visualizations' },
        { sentence: 50, cell_start: 51, cell_end: 51, label: 'Visualizations' },
        { sentence: 51, cell_start: 52, cell_end: 52, label: 'Visualizations' },
        { sentence: 52, cell_start: 53, cell_end: 53, label: 'Visualizations' },
        { sentence: 53, cell_start: 54, cell_end: 54, label: 'Visualizations' },
        { sentence: 54, cell_start: 55, cell_end: 55, label: 'Visualizations' },
        { sentence: 55, cell_start: 56, cell_end: 56, label: 'Visualizations' },
        { sentence: 56, cell_start: 57, cell_end: 57, label: 'Visualizations' },
        { sentence: 57, cell_start: 58, cell_end: 58, label: 'Visualizations' },
        { sentence: 58, cell_start: 59, cell_end: 59, label: 'Visualizations' },
        { sentence: 59, cell_start: 60, cell_end: 60, label: 'Modeling Setup' },
        { sentence: 60, cell_start: 61, cell_end: 61, label: 'Modeling Setup' },
        { sentence: 61, cell_start: 62, cell_end: 62, label: 'Modeling Setup' },
        { sentence: 62, cell_start: 63, cell_end: 63, label: 'Modeling Setup' },
        { sentence: 63, cell_start: 64, cell_end: 64, label: 'Modeling Setup' },
        { sentence: 64, cell_start: 65, cell_end: 65, label: 'Model Training' },
        { sentence: 65, cell_start: 66, cell_end: 66, label: 'Model Training' },
        { sentence: 66, cell_start: 67, cell_end: 67, label: 'Model Prediction' },
        { sentence: 67, cell_start: 68, cell_end: 70, label: 'Model Prediction' },
        { sentence: 68, cell_start: 71, cell_end: 71, label: 'Model Prediction' }
      ];
      

      const renderNarrativeWithColor = () => {
        return (
          <div style={{
            border: '1px solid #ccc',  // Border to make it look like a box
            padding: '16px',  // Space inside the box
            backgroundColor: '#f9f9f9',  // Optional background color
            width: '80%',  // Set the width to a percentage of the screen (or specify px)
            minWidth: '200px',  // Maximum width to ensure it doesn't stretch too much
            minHeight: '200px',  // Ensure the box has some minimum height
            margin: 'auto',  // Center the box horizontally
            borderRadius: '8px',  // Rounded corners
            overflowY: 'auto',  // Scroll if content overflows
            boxSizing: 'border-box',
            textAlign: 'left'
          }}>
            {
                narrativeMap.map((item: any, index: any) => {
                    // Split the narrative into sentences and ensure we add the period back
                    const sentence = narrativeVignette.split('.')[index]?.trim(); // Get the sentence by index and trim any extra spaces
                    if (!sentence) return null; // Handle cases where a sentence is empty or undefined
                    
                    const label: string = item.label;
                    const color = colorMapping[label] || 'black'; // Default to black if no color is found
                
                    return (
                      <p key={index} style={{ color }}>
                        {sentence}.
                      </p>
                    );
                })
            }
          </div>
        );
      };
      

    useEffect(() => {
        console.log("useEffect triggered");
        ///////////////////////////////////////////////
        // FETCH NOTEBOOK from the backend server.js //
        ///////////////////////////////////////////////
        const fetchNotebook = async () => {
            try {
                // const response = await fetch('http://localhost:3001/notebooks/titanic-top-4-with-ensemble-modeling.ipynb');
                const response = await fetch('http://localhost:3001/notebooks/twitter-sentiment-extaction-analysis-eda-and-model.ipynb');
                // const response = await fetch('http://localhost:3001/notebooks/fitbit-fitness-tracker-data.ipynb');
                // const response = await fetch('http://localhost:3001/notebooks/eda-of-bookings-and-ml-to-predict-cancelations.ipynb');
                if (!response.ok) throw new Error('Failed to fetch notebook');
                const notebook = await response.json();
                console.log('notebook response:', notebook);
                const notebookCells = notebook.cells;
                console.log('code cells:', notebookCells);
                return notebookCells;
            } catch (error) {
                console.error('Error:', error);
            }
        };

        // console.log(traceJson);
        // const fetchNotebookCells = async () => {
        //     // directly read in notebook in json format -> TODO: needs to dynamically convert ipynb to json in actual system
            
        //     ///////////////////////
        //     // TWITTER SENTIMENT //
        //     //////////////////////
        //     // console.log('notebook', twitter_sentiment);
        //     // const notebookCells = twitter_sentiment.cells.filter(
        //     //     (cell: { cell_type: string }) => cell.cell_type === "code"
        //     // );

        //     /////////////////////////////
        //     // BOOKINGS CANCELLATIONS //
        //     ////////////////////////////
        //     // const notebookCells = bookings_cancellations.cells.filter(
        //     //     (cell: { cell_type: string }) => cell.cell_type === "code"
        //     // );

        //     //////////////////////
        //     //  FITBIT TRACKER //
        //     /////////////////////
        //     // const notebookCells = fitbit_fitness_tracker_data.cells.filter(
        //     //     (cell: { cell_type: string }) => cell.cell_type === "code"
        //     // );

        //     ////////////////////////
        //     //  TITANIC MODELING //
        //     ///////////////////////
        //     const notebookCells = titanic_top_4_with_ensemble_modeling.cells.filter(
        //         (cell: { cell_type: string }) => cell.cell_type === "code"
        //     );

        //     console.log('notebook cells', notebookCells);
        //     return notebookCells;
        // };
        // creates the color map for the nodes based on LLM analysis labels
        const createColorMap = async (cells: any) => {
            const labelSet = new Set();
            cells.forEach((cell: { label: any; }) => {
                if (cell.label) {
                labelSet.add(cell.label); // add label to set
                }
            });
            // convert set to an array and return
            const labels = Array.from(labelSet);
      
            const colorMap: any = {};
            const colors = [
                "#0A1E1F", "#0F203D", "#24135E", "#6E1381", "#A61166", "#CE100D", "#F99C06",
                "#CFFF24", "#69FF47", "#6BFFA9", "#8FFDFF", "#B3D0FF", "#DFD6FF", "#FEFAFF"       
            ]; 

            for (let index = 0; index < labels.length; index++) {
                const label: any = labels[index];
                colorMap[label] = colors[index % colors.length]; // go through the colors
            }

            return colorMap;
        };
      

        // returns nodes and edges based on notebook cells
        async function initializeGraph(): Promise<any> {
            // previous parameters: inputArray: Array<any>, getNodeData: (item: any) => Node
            let prelimNodes: PreliminaryNode[] = [];
            let prelimEdges: PreliminaryEdges[] = [];
            const lastAssignedTracker: Record<string, number> = {};
            
            const notebookCells = await fetchNotebook();

            const colorMap = await createColorMap(notebookCells);
            setColorMap(colorMap);
            
            console.log('test notebook cells', notebookCells);
            for (let i = 0; i < notebookCells.length; i++) {
                const cell = notebookCells[i];
                const code = cell.source.join("\n");
                console.log('cell', cell);
    
                // (1) TRACKING THE OUTPUT ARTIFACTS OF A CELL
                let artifacts: Array<string> = [];
                if (cell.outputs) {
                    const outputs = cell.outputs;
                    for (const output of outputs) {
                        console.log('output', output)
                        // grabbing the outputs data object in json
                        if ('data' in output) { 
                            if (output.data) {
                                // checking for visualization artifacts
                                if (output.output_type === "display_data") {
                                    artifacts.push("vis");
                                }
                                // checking for df artifacts 
                                else if (output.output_type === "execute_result") {
                                    if ('text/html' in output.data) {
                                        for (const line of output.data['text/html']) {
                                            if (line.includes('<table')) {
                                                artifacts.push("df");
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
    
                // (2) INITIALIZING CELLS BASED ON VARIABLES ASSIGNED OR USED FOR EDGE CREATION
                const { assigned, used } = extractVariablesFromCode(code);
                console.log('code', i+1, code);
                // console.log('assigned', assigned);
                // console.log('used', used);
                
                for (let variable of assigned) {
                    lastAssignedTracker[variable] = (i+1);
                }
    
                for (let variable of used) {
                    // console.log('tracker', lastAssignedTracker);
                    const source = lastAssignedTracker[variable];
                    // console.log('source', variable, source);
                    if (source != null) {
                        // console.log('source exists', source);
                        prelimEdges.push({
                            source: source.toString(),
                            target: (i+1).toString(),
                        });
                        // console.log('edges', prelimEdges);
                    }
                }
    
                // (3) MAIN NODE CREATION
                    // for each notebook cell,
                    // extract cellId
                    // extract uuid (unique for each run of cell?)
                    // extract all variables created in it
                    // extract all variables that are updated in it
                    // code in source : string[]
                    // pushing these nodes before they have positions
                const nodeColor = colorMap[cell.label] || "#B0BEC5"; // Default to gray if no color is found
                console.log('nodeColor', nodeColor)
                prelimNodes.push({
                    id: (i + 1).toString(),
                    data: { label: (i+1).toString(), backgroundColor: nodeColor }
                });
    
                // (3) SATELLITE NODE CREATION
                artifacts.forEach((artifact, index) => {
                    console.log('artifact', i+1, artifact)
                    const satelliteNodeId = `${i+1}-artifact-${index}`;
                    prelimNodes.push({
                        id: satelliteNodeId,
                        data: { label: artifact }
                    });
                    // NOTE: don't need to create an edge actually, reactflow supports floating nodes~
                    // creating edge from main node to satellite node
                    // prelimEdges.push({
                    //     source: i.toString(),
                    //     target: satelliteNodeId,
                    //     style: satelliteEdgeStyle
                    // });
                });
            }
    
            // process nodes given layout to add position 
            const { edges, nodes } = calculateGraphLayout(
                prelimNodes,
                prelimEdges
            );
    
            return { edges, nodes };
        }

        // call fn at end of use effect to populate graph
        initializeGraph().then((result) => {
            console.log("result", result);
            setNodes(result.nodes);
            setEdges(result.edges);
        });


    }, []);

    return (
        <div style={{ width: "100vw", height: "100vh" }}>
            {renderNarrativeWithColor()}
            <ReactFlow
                nodes={nodes}
                edges={edges}
                onConnect={onConnect}
                fitView
                nodeTypes={nodeTypes}
                style={{ background: "#F3F4F6" }}
            >
                <MiniMap />
                <Controls />
            </ReactFlow>
            <Legend colorMap={colorMap} />
        </div>
    );
};

// helper function to add posiitons to preliminary nodes
function calculateGraphLayout(nodes: any, edges: any): any {
    const g = new dagre.graphlib.Graph();

    // Set graph properties
    g.setGraph({
        rankdir: "TB", // Top to bottom layout
        align: "UL", // Align upper left
        nodesep: 60, // smaller horizontal distance between nodes
        ranksep: 200, // greater vertical distance between nodes
        marginx: 20, // Pixels of margin around the graph
        marginy: 20,
    });

    // Default to assign object as edge label
    g.setDefaultEdgeLabel(() => ({}));

    // adding nodes to the graph
    nodes.forEach((node: any) => {
        g.setNode(node.id, {
            label: node.label,
            width: 100, // Node width in pixels
            height: 60, // Node height in pixels
        });
    });

    // adding edges to the graph
    edges.forEach((edge: any) => {
        g.setEdge(edge.source, edge.target);
    });

    // layout the graph
    dagre.layout(g);

    // creating new node array and add calculated positions
    // position is autolayout calculated by dagre 
    const positionedNodes: Node[] = nodes.flatMap((node: any) => {
        const nodeWithPosition = g.node(node.id);
        // check if the node is a satellite node
        if (node.id.includes("-artifact-")) {
            // get the main node ID from the satellite node's ID
            const mainNodeId = node.id.split("-artifact-")[0];
            const mainNodePosition = g.node(mainNodeId);
            // set position for the satellite node in radial distr
            const angle = (parseInt(node.id.split("-artifact-")[1], 10) / 15) * 2 * Math.PI;
            const radius = 90; // distance from the main node
    
            return {
                id: node.id,
                type: "SatelliteNode", // custom type for satellite nodes
                position: {
                    x: mainNodePosition.x + radius * Math.cos(angle),
                    y: mainNodePosition.y + radius * Math.sin(angle),
                },
                data: {
                    label: node.data.label,
                },
            };
        }
    
        // Main node positioning
        return {
            id: node.id,
            type: "MainNode",
            position: {
                x: nodeWithPosition.x,
                y: nodeWithPosition.y,
            },
            data: {
                label: node.data.label,
                backgroundColor: node.data.backgroundColor
            },
        };
    });
    const wrangledNodes = positionedNodes;

    // make edges schema compatible 
    const wrangledEdges = edges.map((edge: any, i: number) => {
        return {
            id: i,
            target: edge.target,
            source: edge.source,
        };
    });

    // returning compatible nodes, edges
    return { nodes: wrangledNodes, edges: wrangledEdges };
}

export default Graph;
